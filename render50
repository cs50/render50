#!/usr/bin/env python

from __future__ import print_function
import argparse
import glob
import os
import signal
import sys
import textwrap

from backports.shutil_which import which
from backports.shutil_get_terminal_size import get_terminal_size
from natsort import natsorted
from pygments import highlight
from pygments.lexers import PythonLexer
from pygments.formatters import HtmlFormatter
import termcolor


def main():
    """
    """

    # Exit on ctrl-c
    def handler(signum, frame):
        print("")
        sys.exit(1)
    signal.signal(signal.SIGINT, handler) 
   
    # Parse command-line arguments
    parser = argparse.ArgumentParser(description="A command-line tool that "
                                                 "renders source code as a PDF.")
    parser.add_argument("-r", "--recursive",
            action="store_true",
            help="recurse into directories")
    parser.add_argument("output", help="file to output")
    parser.add_argument("input", help="input to render", nargs="+")
    parser.add_argument("-i", "--include", action="append", help="pattern to include")
    parser.add_argument("-x", "--exclude", action="append", help="pattern to exclude")
    args = parser.parse_args(sys.argv[1:])
    
    # Ensure output ends in .pdf
    output = args.output
    if not output.lower().endswith(".pdf"):
        output += ".pdf"

    # Create parent directory as needed
    output = os.path.realpath(output)
    dirname = os.path.dirname(output)
    if not os.path.isdir(dirname):
        while True:
            s = input("Create {}? ".format(dirname)).strip()
            if s.lower() in ["n", "no"]:
                raise RuntimeError()
            elif s.lower() in ["y", "yes"]:
                try:
                    os.makedirs(dirname)
                except Exception:
                    e = RuntimeError("Could not create {}.".format(dirname))
                    e.__cause__ = None
                    raise e

    # Prompt whether to overwrite file as needed
    if os.path.exists(output):
        while True:
            s = input("Overwrite {}? ".format(output))
            if s.lower() in ["n", "no"]:
                raise RuntimeError()

    # Check for includes
    includes = []
    if args.include:
        for i in args.include:
            includes.append(i.replace(".", "\.").replace("|", "\|").replace("*", ".*"))

    # Check for excludes
    excludes = []
    if args.exclude:
        for i in args.exclude:
            excludes.append(i.replace(".", "\.").replace("|", "\|").replace("*", ".*"))

    # Check stdin for inputs else command line
    patterns = []
    if len(args.input) == 1 and args.input[0] == "-":
        patterns = sys.stdin.read().splitlines()
    else:
        patterns = args.input

    # Glob patterns lest shell (e.g., Windows) not have done so
    inputs = []
    for pattern in patterns:
        paths = natsorted(glob.glob(pattern))
        inputs += paths

    # Queue files and directories to render
    queue = []
    for input in inputs:
        pass # TODO

    print(inputs)
    sys.exit()

    # Check for excludes
    # TODO

    # Check for inputs
    inputs = args.input
    if "--" in args.input:
        inputs += sys.stdin.readlines()

    # Glob patterns lest shell (e.g., Windows) not have done so
    # TODO

    # Queue files for rendering
    # TODO
    queue = []
    for input in inputs:
        pass

    # Render files
    # TODO
    for file in queue:
        pass

    print(args)


def cprint(text="", color=None, on_color=None, attrs=None, **kwargs):
    """Colorizes text (and wraps to terminal's width)."""

    # Assume 80 in case not running in a terminal
    columns, _ = get_terminal_size((80, 0))

    # Only python3 supports "flush" keyword argument
    if sys.version_info < (3, 0) and "flush" in kwargs:
        del kwargs["flush"]

    # Print text
    termcolor.cprint(textwrap.fill(text, columns, drop_whitespace=False),
                     color=color, on_color=on_color, attrs=attrs, **kwargs)


def excepthook(type, value, tb):
    """Report an exception."""
    excepthook.ignore = False
    if type is RuntimeError and str(value):
        cprint(str(value), "yellow")
    cprint(str(value), "yellow")
    cprint("Rendering cancelled.", "red")
sys.excepthook = excepthook


if __name__ == "__main__":
    main()
