#!/usr/bin/env python

from __future__ import print_function
import argparse
import copy
import glob
import os
import re
import signal
import sys
import tempfile
import textwrap
import traceback
import warnings

from backports.shutil_which import which
from backports.shutil_get_terminal_size import get_terminal_size
from natsort import natsorted, ns
from pygments import highlight
from pygments.formatters import HtmlFormatter
from pygments.lexers import guess_lexer, guess_lexer_for_filename
from pygments.lexers.special import TextLexer
import PyPDF2
import termcolor


# require python 2.7+
if sys.version_info < (2, 7):
    sys.exit("You have an old version of python. Install version 2.7 or higher.")
if sys.version_info < (3, 0):
    input = raw_input


def main():

    # Exit on ctrl-c
    def handler(signum, frame):
        print("")
        sys.exit(1)
    signal.signal(signal.SIGINT, handler) 
   
    # Parse command-line arguments
    parser = argparse.ArgumentParser(description="A command-line tool that "
                                                 "renders source code as a PDF.")
    parser.add_argument("-r", "--recursive", action="store_true", help="recurse into directories")
    parser.add_argument("-i", "--include", action="append", help="pattern to include")
    parser.add_argument("--no-color", action="store_true", help="disable syntax highlighting")
    parser.add_argument("-s", "--size", help="size of page")
    parser.add_argument("-x", "--exclude", action="append", help="pattern to exclude")
    parser.add_argument("-y", "--side-by-side", action="store_true", help="render two files side-by-side")
    parser.add_argument("output", help="file to output")
    parser.add_argument("input", help="input to render", nargs="+")
    args = parser.parse_args(sys.argv[1:])
 
    # Ensure output ends in .pdf
    output = args.output
    if not output.lower().endswith(".pdf"):
        output += ".pdf"

    # Ensure there are two and only two input files if side-by-side specified
    if args.side_by_side and len(args.input) != 2:
        raise RuntimeError("Can only render 2 files side-by-side.")

    # Check for size
    size = args.size
    if not size:
        if args.side_by_side:
            size = "letter portrait"
        else:
            size = "letter landscape"
    elif args.side_by_side and (size == "A4" or size == "letter"):
        size = "{} portrait".format(args.size.strip())
    elif size == "A4" or size == "letter":
        size = "{} landscape".format(args.size.strip())
    else:
        raise RuntimeError("Can only render 2 files side-by-side.")

    # Create parent directory as needed
    dirname = os.path.dirname(os.path.realpath(output))
    if not os.path.isdir(dirname):
        while True:
            s = input("Create {}? ".format(dirname)).strip()
            if s.lower() in ["n", "no"]:
                raise RuntimeError()
            elif s.lower() in ["y", "yes"]:
                try:
                    os.makedirs(dirname)
                except Exception:
                    e = RuntimeError("Could not create {}.".format(dirname))
                    e.__cause__ = None
                    raise e

    # Prompt whether to overwrite file as needed
    if os.path.exists(output):
        while True:
            s = input("Overwrite {}? ".format(output))
            if s.lower() in ["y", "yes"]:
                break
            elif s.lower() in ["n", "no"]:
                raise RuntimeError()

    # Check for includes
    includes = []
    if args.include:
        for i in args.include:
            includes.append(re.escape(i).replace("\*", ".*"))

    # Check for excludes
    excludes = []
    if args.exclude:
        for x in args.exclude:
            excludes.append(re.escape(x).replace("\*", ".*"))

    # Check stdin for inputs else command line
    patterns = []
    if len(args.input) == 1 and args.input[0] == "-":
        patterns = sys.stdin.read().splitlines()
    else:
        patterns = args.input

    # Glob patterns lest shell (e.g., Windows) not have done so, ignoring empty patterns
    paths = []
    for pattern in patterns:
        if pattern:
            paths += natsorted(glob.glob(pattern), alg=ns.IGNORECASE)

    # Candidates to render
    candidates = []
    for path in paths:
        if not os.access(path, os.R_OK):
            raise RuntimeError("Could not read: {}".format(path))
        if os.path.isfile(path):
            candidates.append(path)
        elif os.path.isdir(path):
            files = []
            for dirpath, dirnames, filenames in os.walk(path):
                for filename in filenames:
                    files.append(os.path.join(dirpath, filename))
            natsorted(files, alg=ns.IGNORECASE)
            candidates += files
        else:
            raise RuntimeError("Unsupported: {}".format(path))

    # Filter candidates
    queue = []
    for candidate in candidates:

        # Skip implicit exclusions
        if includes and not re.search(r"^" + r"|".join(includes) + "$", candidate):
            continue

        # Skip explicit exclusions
        if excludes and re.search(r"^" + r"|".join(excludes) + "$", candidate):
            continue

        # Skip dotfiles
        if os.path.basename(candidate).startswith("."):
            continue

        # Queue candidate for rendering
        queue.append(candidate)

    # Render queued files
    documents = []
    for queued in queue:

        # Buffer this document
        doc = create_document(queued, size, args.no_color)
        if doc:
            documents.append(doc)

    # Write documents to PDF
    # https://github.com/Kozea/WeasyPrint/issues/212#issuecomment-52408306
    if documents:

        # If we're in side-by-side mode, write two temp PDFs, then concatenate them
        if args.side_by_side:

            # Write temp PDFs for first and second document
            _, left_temp = tempfile.mkstemp()
            _, right_temp = tempfile.mkstemp()
            _, blank_temp = tempfile.mkstemp()

            documents[0].write_pdf(left_temp)
            documents[1].write_pdf(right_temp)

            # Generate and write blank PDF for filler pages
            generated_blank_doc = generate_blank_pdf(blank_temp, size=size)

            merge_pdfs(left_temp, right_temp, blank_temp, output)

            os.remove(left_temp)
            os.remove(right_temp)
            os.remove(blank_temp)
        else:
            pages = [page for document in documents for page in document.pages]
            documents[0].copy(pages).write_pdf(output)

        cprint("Rendered {}.".format(output), "green")
    else:
        cprint("Nothing to render.", "red")


def create_document(path=None, size='letter portrait', no_color=True, content=None):
    """
    Given a path, a size, and whether to color it, render a document to a PDF and return it.
    Returns None on failure. Can be passed no arguments to create a blank PDF.
    """
    # Stylize document based on path or content
    style_content = content if content else '{}'.format(path.replace("'", "\'"))
    stylesheets = [
            CSS(string="@page {{ border-top: 1px #808080 solid; margin: 0.5in; size: {}; }}".format(size.replace(";", "\;"))),
            CSS(string="@page {{ @top-right {{ color: #808080; content: '{}'; }} }}".format(style_content)),
            CSS(string="* { font-family: monospace; font-size: 10pt; }"),
            CSS(string=HtmlFormatter().get_style_defs('.highlight')),
            CSS(string=".highlight { background: initial; }"),
            CSS(string=".lineno { color: #808080; }"),
            CSS(string=".lineno:after { content: '  '; }")]

    # Generate PDF from content if no path to read from is specified
    if not path:
        # Render document
        cprint("Rendering document with content: '{}'".format(content))
        document = HTML(string=content).render(stylesheets=stylesheets)

        return document
    else:
        # Open file
        with open(path, "rb") as file:

            # Read file unless content is pre-specified
            code = file.read().decode("utf-8", "ignore") if not content else content

            # Skip binary files
            if "\x00" in code:
                cprint("Skipping {} because binary...".format(path), "yellow")
                return None

            # Highlight code unless file is empty, using inline line numbers to avoid
            # page breaks in tables, https://github.com/Kozea/WeasyPrint/issues/36
            string = ""
            if code.strip() and not no_color:
                try:
                    lexer = guess_lexer_for_filename(path, code)
                except:
                    try:
                        lexer = guess_lexer(code)
                    except:
                        lexer = TextLexer()
                string = highlight(code, lexer, HtmlFormatter(linenos="inline", nobackground=True))
            else:
                string = highlight(code, TextLexer(), HtmlFormatter(linenos="inline", nobackground=True))

            # Render document
            cprint("Rendering {}...".format(path))
            document = HTML(string=string).render(stylesheets=stylesheets)

            # Bookmark document
            document.pages[0].bookmarks = [(1, path, (0, 0))]

            return document


def generate_blank_pdf(path, size='letter potrait'):
    """
    Generates a blank PDF document and then writes it to a specified path.
    """
    blank_doc = create_document(content=' ', size=size)
    blank_doc.write_pdf(path)


def merge_pdfs(left_path, right_path, blank_path, output):
    """ 
    Combines two temp PDFs page by page, side by side, filling in blank pages for shorter PDF side. 
    https://stackoverflow.com/questions/24580454/python-pypdf2-join-pages/34646677#34646677
    """
    with open(left_path, "rb") as left_file, open(right_path, "rb") as right_file, open(blank_path, "rb") as blank_file:
        # Load input pdfs
        left_pdf = PyPDF2.PdfFileReader(left_file)
        right_pdf = PyPDF2.PdfFileReader(right_file)
        blank_pdf = PyPDF2.PdfFileReader(blank_file)

        # Determine which PDF is larger
        left_pages = left_pdf.getNumPages()
        right_pages = right_pdf.getNumPages()
        pages_to_iterate = max(left_pages, right_pages)

        completed_pages = []

        # Iterate through both PDFs, creating side-by-side pages for both. Insert blanks onto whichever side is shorter
        for page_num in range(pages_to_iterate):

            # Insert blanks onto left side if we've gone past left PDF's page count
            if page_num >= left_pages:
                output_pdf = copy.copy(blank_pdf.getPage(0))
            else:
                output_pdf = copy.copy(left_pdf.getPage(page_num))
            
            # Insert blanks onto right side if we've gone past right PDF's page count
            if page_num >= right_pages:
                second_pdf = copy.copy(blank_pdf.getPage(0))
            else:
                second_pdf = copy.copy(right_pdf.getPage(page_num))

            # Dimensions for offset from loaded page (adding it to the right)
            offset_x = output_pdf.mediaBox[2]
            offset_y = 0

            # Add second page to first one
            output_pdf.mergeTranslatedPage(second_pdf, offset_x, offset_y, expand=True)
            completed_pages.append(output_pdf)

        # Write finished pdf
        with open(output, 'wb') as out_file:
            write_pdf = PyPDF2.PdfFileWriter()

            for page in completed_pages:
                write_pdf.addPage(page)
            
            write_pdf.write(out_file)


def cprint(text="", color=None, on_color=None, attrs=None, **kwargs):
    """Colorize text (and wraps to terminal's width)."""

    # Assume 80 in case not running in a terminal
    columns, _ = get_terminal_size()
    if columns == 0: columns = 80

    # Only python3 supports "flush" keyword argument
    if sys.version_info < (3, 0) and "flush" in kwargs:
        del kwargs["flush"]

    # Print text
    termcolor.cprint(textwrap.fill(text, columns, drop_whitespace=False, replace_whitespace=False),
                     color=color, on_color=on_color, attrs=attrs, **kwargs)


def excepthook(type, value, tb):
    """Report an exception."""
    excepthook.ignore = False
    if type is RuntimeError and str(value):
        cprint(str(value), "yellow")
    else:
        cprint("Sorry, something's wrong! Let sysadmins@cs50.harvard.edu know!", "yellow")
        traceback.print_exception(type, value, tb)
    cprint("Rendering cancelled.", "red")
sys.excepthook = excepthook


def _inline_min_content_width(context, box, outer=True, skip_stack=None,
                             first_line=False, is_line_start=False):
    """Return the min-content width for an ``InlineBox``.
    The width is calculated from the lines from ``skip_stack``. If
    ``first_line`` is ``True``, only the first line minimum width is
    calculated.
    """
    widths = weasyprint.layout.preferred.inline_line_widths(
        context, box, outer, is_line_start, minimum=True,
        skip_stack=skip_stack)

    if first_line:
        widths = [next(widths)]
    else:
        widths = list(widths)
        widths[-1] -= weasyprint.layout.preferred.trailing_whitespace_size(context, box)
    return weasyprint.layout.preferred.adjust(box, outer, max(widths))


# Check for dependencies
# http://weasyprint.readthedocs.io/en/latest/install.html
try:
    # Ignore warnings about outdated Cairo and Pango (on Ubuntu 14.04, at least)
    warnings.filterwarnings("ignore", category=UserWarning, module="weasyprint")
    from weasyprint import CSS, HTML
except OSError as e:
    if "pangocairo" in str(e):
        e = RuntimeError("Missing dependency. Install Pango.")
        e.__cause__ = None
        raise e
    elif "cairo" in str(e):
        e = RuntimeError("Missing dependency. Install cairo.")
        e.__cause__ = None
        raise e
    else:
        e = RuntimeError(str(e))
        e.__cause__ = None
        raise e
else:
    # Temporary until https://github.com/Kozea/WeasyPrint/milestone/7 deploys
    import weasyprint.layout.inlines
    weasyprint.layout.inlines.inline_min_content_width = _inline_min_content_width
    import weasyprint.layout.preferred
    weasyprint.layout.preferred.inline_min_content_width = _inline_min_content_width


if __name__ == "__main__":
    main()
